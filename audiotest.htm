<!DOCTYPE html>
<HTML>
<HEAD>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<TITLE>Audio Test</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="pianokeys.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="drawbars.css">
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="pianokeys.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="tinysynth.js"></SCRIPT><!-- not needed for drawbar synth  - but testing none the less -->
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="sf2-parser.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript">
function el(x) { return document.getElementById(x); }

"use strict";

function recordPlaybackObject() {
	this.notes = [ ];		// a note is an array of objects with properties delta and midiMessage.
	this.startRecording = function() { this.notes = [ ]; }
}

function insertDrawbars(destDiv, instrumentObject) {
	//--- inserts drawbars into a Div to control an instrument's harmonics
	var ndb = instrumentObject.getNumDrawbars();
	for (var i = 0; i < ndb; i++) {
		var setupDrawbar = function(db,ndb) {
			dbl = ["16'","5<sup>1/3</sup>'","8'","4'","2<sup>2/3</sup>'","2","1<sup>3/5</sup>'","1<sup>1/3</sup>'","1'"];
			var newDrawbar = document.createElement("input");
			newDrawbar.type = "range";
			newDrawbar.className = "drawbar";
			newDrawbar.min = 0; newDrawbar.max = 8;
			newDrawbar.value = instrumentObject.getDrawbarDefault(ndb-db-1);
			newDrawbar.addEventListener("change", function(evt) {
				instrumentObject.setDrawbar(ndb-db-1, parseInt(newDrawbar.value,10), 0);
			});
			destDiv.appendChild(newDrawbar);
			var drawbarLabel = document.createElement("span"); drawbarLabel.innerHTML = dbl[ndb-db-1];
			var drawbarBr = document.createElement("br"); destDiv.appendChild(drawbarLabel); destDiv.appendChild(drawbarBr);
		};
		setupDrawbar(i,ndb);
	}
}

function insertEnvelope(destDiv, instrumentObject) {
	//--- draws the envelope controls
	var ienv = instrumentObject.getEnvelopeObject();
	var addParameter = function(parmName, minValue, maxValue, label) {
		var newSlider = document.createElement("input"); newSlider.type = "range";
		newSlider.className = "other-slider";
		newSlider.min = minValue; newSlider.max = maxValue; newSlider.value = ienv[parmName];
		var sliderLabel = document.createElement("span"); sliderLabel.innerText = label;
		var sliderBr = document.createElement("br");
		newSlider.addEventListener("change", function(evt) {
			instrumentObject.setEnvelope(parmName, parseInt(newSlider.value,10));
		});
		destDiv.appendChild(newSlider); destDiv.appendChild(sliderLabel); destDiv.appendChild(sliderBr);
	};
	var maxDelay = 1000;		// max delay for an envelope time parameter is 1s
	addParameter("a",0,maxDelay,"Attack");
	addParameter("h",0,maxDelay,"Hold");
	addParameter("d",0,maxDelay,"Decay");
	addParameter("s",0,100,"Sustain (%Max)");
	addParameter("r",0,maxDelay*4,"Release");		// Release allows much longer time configuration to make ringing sounds.
	addParameter("expFlag",0,1,"Exponential");
}

function insertGeneralControls(destDiv, instrumentObject) {
	//--- some more controls I like
	var addZeroOneSlider = function(name, sliderName) {
		var newSlider = document.createElement("input"); newSlider.type = "range"; newSlider.className = "other-slider";
		newSlider.min = 0; newSlider.max = 1; newSlider.step = 0.05; newSlider.value = instrumentObject["get" + sliderName]();
		var sliderLabel = document.createElement("span"); sliderLabel.innerText = name;
		var sliderBr = document.createElement("br");
		newSlider.addEventListener("change", function(evt) { instrumentObject["set"+sliderName](parseFloat(newSlider.value),0); });
		destDiv.appendChild(newSlider); destDiv.appendChild(sliderLabel); destDiv.appendChild(sliderBr);
	};
	addZeroOneSlider("Volume", "MainVolume");
	addZeroOneSlider("Tremolo Freq", "TremoloFrequency");
	addZeroOneSlider("Tremolo Gain", "TremoloGain");
	addZeroOneSlider("Pitch Bend", "PitchBend");
	addZeroOneSlider("Pitch Bend Sensitivity", "PitchBendSensitivity");
	addZeroOneSlider("Vibrato Freq", "VibratoFrequency");
	addZeroOneSlider("Vibrato Gain", "VibratoGain");
}

var adjWave;
var synth; 		// tinysynth

//--- tinysynth testing routines from tinysynth website

function loadMidi(files){
  var reader = new FileReader();
  reader.onload=function(e) {
    synth.loadMIDI(reader.result);
  };
  reader.readAsArrayBuffer(files[0]);
}
function playMidi(){
  synth.playMIDI();
}
function stopMidi(){
  synth.stopMIDI();
}
function SetProgram(p){
  synth.send([0xc0,p]);
}
function Init(){
  synth=new WebAudioTinySynth({voices:64});
  for(var i=0;i<128;++i){
    var o=document.createElement("option");
    o.innerHTML=i + ": " + synth.getTimbreName(0,i);
    document.getElementById("prog").appendChild(o);
  }
  synth.setSoundfontPath("./bsoundfonts");
  synth.loadInstruments([0,11,128],function(errObj) {	// load piano, drums, vibes
	  el("inststatus").innerText = errObj.errMsg;
  	  }, function() { el("inststatus").innerText = "Loaded successfully"; console.log("Instruments loaded."); },
	  function(i,n) { console.log("Loading Instrument " + i + " of " + n); });  // shows example of progress callback
  synth.setQuality(2);
  setInterval(function(){
    var st=synth.getPlayStatus();
    document.getElementById("status").innerHTML="Play:"+st.play+"  Pos:"+st.curTick+"/"+st.maxTick;
  },100);
}

function onLoadFunction() {
	//--- tinysynth keyboard setup
	pianoKeyDisplay.createPianoKeyboard(el("tskeyboard"),0,127,25,21,108,function(x) {
		x.keyDown = false;
		x.onNoteOn = function(noteNumber, channel, velocity, keyButton, startTime) {
			if (x.keyDown) return;	// debounce
			if (keyButton) keyButton.style.backgroundColor = "pink";
			x.keyDown = true;
			var ch = parseInt(el("kbdchannel").value,10) & 0x0F;
			synth.send([0x90 + ch,noteNumber & 0x7F,velocity & 0x7F]);
		};
		x.onNoteOff = function(noteNumber, channel, keyButton, startTime) {
			if (!x.keyDown) return; x.keyDown = false;
			if (keyButton) keyButton.style.backgroundColor = "";
			var ch = parseInt(el("kbdchannel").value,10) & 0x0F;
			synth.send([0x80 + ch,noteNumber & 0x7F,0]);
		};
	});
	Init();  // init tiny synth
	synth.setupMIDIDevices(function() { refreshMidiUI(); }, function() { el("midiinputs").innerText = "No Midi Device Support"; } )
}

var numInputCheckboxes = 0, numOutputCheckboxes = 0;

function readMidiUI() {
	// reads the checkboxes in the input/output section to set up inputs and outputs
	var inputList = [ ];
	for (var i = 0; i < numInputCheckboxes; i++) {
		if (el("midiinput_" + i).checked) inputList.push(el("midiinput_" + i).getAttribute("midiid"));
	}
	synth.setInput(inputList);
	var outputList = [ ];
	for (var i = 0; i < numOutputCheckboxes; i++) {
		if (el("midioutput_" + i).checked) outputList.push(el("midioutput_" + i).getAttribute("midiid"));
	}
	synth.setOutput(outputList);
}

function refreshMidiUI() {
	synth.refreshInputs(); synth.refreshOutputs();
	var myInputs = synth.getInputs(); var myOutputs = synth.getOutputs();
	el("midiinputs").innerHTML = ""; numInputCheckboxes = myInputs.length;
	for (var i = 0; i < myInputs.length; i++) {
		var newCheckbox = document.createElement("input"); newCheckbox.type="checkbox";
		newCheckbox.checked = (synth.selectedInputs.indexOf(myInputs[i].id) !== -1);
		newCheckbox.setAttribute("midiid",myInputs[i].id);
		newCheckbox.id = "midiinput_" + i;
		newCheckbox.addEventListener("click",readMidiUI);
		var newLabel = document.createElement("span");
		newLabel.innerText = myInputs[i].name;
		var newBr = document.createElement("br");
		el("midiinputs").appendChild(newCheckbox); el("midiinputs").appendChild(newLabel); el("midiinputs").appendChild(newBr);
	}
	var myOutputs = synth.getOutputs(); var myOutputs = synth.getOutputs();
	el("midioutputs").innerHTML = ""; numOutputCheckboxes = myOutputs.length;
	for (var i = 0; i < myOutputs.length; i++) {
		var newCheckbox = document.createElement("input"); newCheckbox.type="checkbox";
		newCheckbox.checked = (synth.selectedOutputs.indexOf(myOutputs[i].id) !== -1);
		newCheckbox.setAttribute("midiid",myOutputs[i].id);
		newCheckbox.id = "midioutput_" + i;
		newCheckbox.addEventListener("click",readMidiUI);
		var newLabel = document.createElement("span");
		newLabel.innerText = myOutputs[i].name;
		var newBr = document.createElement("br");
		el("midioutputs").appendChild(newCheckbox); el("midioutputs").appendChild(newLabel); el("midioutputs").appendChild(newBr);
	}
}

function showDrawbar() {
	el('drawbarstuff').style.display = '';	
	//--- now add event listeners for controls of the drawbar organ
	adjWave = new drawbarOrgan(synth.actx);		// the synth connects it to appropriate channel outputs when it is selected
	synth.setProgramOverride(16,[[adjWave,-1]]);   // redirect the Drawbar Organ patch to the custom instrument.
	insertDrawbars(el("drawbars"),adjWave);
	insertEnvelope(el("envelope"),adjWave);
	insertGeneralControls(el("generalcontrols"),adjWave);
	synth.setProgram(0,16);  // set to organ
	el("prog").value = 16;
}

//
//	A test of a Sound-Font-2-compatible note routine that can be plugged into the tinysynth to
//	offer full SF2 capabilities.  Is it possible?
//  Turns a note on or off based on the noteOn flag.  Creates and starts the audio nodes and
//	returns an array of output nodes, each of which should be connected to the gain node for the
//  note to link into the synthesizer.  Knows nothing about MIDI channels, etc., since that is
//  handled by the higher level in tinysynth.  t is the time for the events to start happening
//  according to the audio clock in the relevant audio context, ctx.  Not sure if velocity is
//  needed, that could be handled by the gain node they all get attached to???!!!
//
//	I might change it to return a structure of which the audio-nodes array is one element,
//  and parameters like release time are the rest, so that tinysynth can handle note-off itself.
//	Depends on how complex note-off turns out to be.
//
//	Returns false if the note cannot be played (e.g. no sample available).  Presumably then you
//  fall back to Quality Level 2 or 1 or something.
//

function sf2note(noteOn /* boolean */, parser, bankNumber, programNumber, noteNumber, t, ctx, velocity) {
	if (!parser.MIDIMap) return false;  // need the midi map generated after loading soundfont
	if (!parser.MIDIMap[bankNumber]) return false;
	if (!parser.MIDIMap[bankNumber][programNumber]) return false;

}

//
//	Actually before we start playing notes, we need to process all the notes.  We can
//	do it by generating a handy fast version of each note that we could play, that
// 	immediately links to the samples and parameters we need.  That is what this returns.
//
function sfProcessingClass() {	// creates sfProcessing object
	//--- UNIT CONVERSION functions for various units that are referenced in Soundfonts (there's a lot!)
	var uc = {		// Unit Conversion: For combining SF parameters, or converting to WebAudio ones.
		cent_to_semitone: function(a) { return a/100; },
		semitone_to_cent: function(a) { return a*100; },
		midikey_to_hertz: function(a) { return Math.pow(2, (a - 69) / 12) * 440.0;},
		hertz_to_midikey: function(a) { return (Math.log(a/440.0)/Math.log(2))*12+69; },
		
	};
	//--- FUNCTIONS assigned to various data types within sound fonts, so they can "handle" their own operations based on their type.
	var combineParmsAdding = function(a,b,parmName) {
		//--- The combine parms routines are different ways of putting a parameter from b into a, where b can override a (e.g. b could be a preset and a could be an instrument, etc.).  A and B are objects with multiple parameters in them.
		if (!b.hasOwnProperty(parmName)) return;
		if (b[parmName]===null) return;
		if (!a.hasOwnProperty(parmName)) a[parmName] = b[parmName];
		else a[parmName] += b[parmName];
	};
	var combineParmsMultiplying = function(a,b,parmName) {
		if (!b.hasOwnProperty(parmName)) return;
		if (b[parmName]===null) return;
		if (!a.hasOwnProperty(parmName)) a[parmName] = b[parmName];
		else a[parmName] *= b[parmName];
	};
	var combineParmsSubstituting = function(a,b,parmName) {
		if (!b.hasOwnProperty(parmName)) return;
		if (b[parmName]===null) return;
		a[parmName] = b[parmName];
	};
	var combineParmsIgnoring = function(a,b,parmName) { };
	//--- DATA about SoundFont parameters!  Mostly straight from the SoundFont public implementation document!
	var typeInfo = { 		// Types of parameters have associated functions, etc., which if they exist, override those of units.
		'index': { combine: combineParmsIgnoring, },
		'range': { combine: combineParmsIgnoring, },
		'sample': { },		// combine is done at the unit level
		'value': { },		// combine is done at the unit level
		'substitution': { combine: combineParmsSubstituting,  },
	};
	var unitInfo = {		// Units of measure have associated combining functions, etc.
		'smpls': { combine: combineParmsAdding, },
		'32k_smpls': { combine: combineParmsAdding, },
		'cent_fs': { parent_unit: 'cent', },
		'cent': { combine: combineParmsAdding, },
		'cB': { combine: combineParmsAdding, },
		'cB_fs': { parent_unit: 'cB', },
		'cB_attn': { parent_unit: 'cB', },
		'tenth_percent': { combine: combineParmsAdding, },
		'minus_tenth_percent': { combine: combineParmsAdding, },
		'timecent': { combine: combineParmsAdding, },
		'tcent_per_key': { parent_unit: 'timecent', },
		'index': { combine: combineParmsSubstituting, },
		'range': { combine: combineParmsIgnoring, },
		'midikey': { combine: combineParmsSubstituting, },
		'midivel': { combine: combineParmsSubstituting, },
		'bitflags': { combine: combineParmsIgnoring, },
		'semitone': { combine: combineParmsAdding, },
		'cent_per_key': { parent_unit: 'cent', },
		'number': { combine: combineParmsIgnoring, },
	};
	var parmInfo = {		// For every parameter that might be returned by the parser, we need to know what to do from the SF2 spec.
      'startAddrsOffset': { unit: 'smpls',min:null,max:null,default:0,type:'sample',},
      'endAddrsOffset': { unit: 'smpls',min:null,max:null,default:0,type:'sample',},
      'startloopAddrsOffset': {unit: 'smpls',min:null,max:null,default:0,type:'sample',},
      'endloopAddrsOffset': {unit: 'smpls',min:null,max:null,default:0,type:'sample',},
      'startAddrsCoarseOffset': {unit: '32k_smpls',min:null,max:null,default:0,type:'sample',},
      'modLfoToPitch': {unit:'cent_fs',min:-12000,max:12000,default:0,type:'value',},
      'vibLfoToPitch': {unit:'cent_fs',min:-12000,max:12000,default:0,type:'value',},
      'modEnvToPitch': {unit:'cent_fs',min:-12000,max:12000,default:0,type:'value',},
      'initialFilterFc': {unit: 'cent',min:1500,max:13500,default:13500,type:'value',},
      'initialFilterQ': {unit: 'cB',min:0,max:960,default:0,type:'value',},
      'modLfoToFilterFc': {unit:'cent_fs',min:-12000,max:12000,default:0,type:'value',},
      'modEnvToFilterFc': {unit:'cent_fs',min:-12000,max:12000,default:0,type:'value',},
      'endAddrsCoarseOffset': {unit: '32k_smpls',min:null,max:null,default:0,type:'sample',},
      'modLfoToVolume': {unit: 'cB_fs',min:-960,max:960,default:0,type:'value',},
      'chorusEffectsSend': {unit: 'tenth_percent',min:0,max:1000,default:0,type:'value',},
      'reverbEffectsSend': {unit: 'tenth_percent',min:0,max:1000,default:0,type:'value',},
      'pan': {unit: 'tenth_percent',min:-500,max:500,default:0,type:'value',},
      'delayModLFO': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'freqModLFO': {unit: 'cent',min:-16000,max:4500,default:0,type:'value',},
      'delayVibLFO': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'freqVibLFO': {unit: 'cent',min:-16000,max:4500,default:0,type:'value',},
      'delayModEnv': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'attackModEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'holdModEnv': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'decayModEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'sustainModEnv': {unit:'minus_tenth_percent',min:0,max:1000,default:0,type:'value',},
      'releaseModEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'keynumToModEnvHold': {unit:'tcent_per_key',min:-1200,max:1200,default:0,type:'value',},
      'keynumToModEnvDecay': {unit:'tcent_per_key',min:-1200,max:1200,default:0,type:'value',},
      'delayVolEnv': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'attackVolEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'holdVolEnv': {unit:'timecent',min:-12000,max:5000,default:-12000,type:'value',},
      'decayVolEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'sustainVolEnv': {unit: 'cB_attn',min:0,max:1440,default:0,type:'value',},
      'releaseVolEnv': {unit:'timecent',min:-12000,max:8000,default:-12000,type:'value',},
      'keynumToVolEnvHold': {unit:'tcent_per_key',min:-1200,max:1200,default:0,type:'value',},
      'keynumToVolEnvDecay': {unit:'tcent_per_key',min:-1200,max:1200,default:0,type:'value',},
      'instrument': {unit: 'index',min:null,max:null,default:null,type:'index',},
      'keyRange': {unit: 'range',min:null,max:null,default:null,type:'range',},
      'velRange': {unit: 'range',min:null,max:null,default:null,type:'range',},
      'startloopAddrsCoarseOffset': {unit: 'smpls',min:null,max:null,default:0,type:'sample',},
      'keynum': {unit: 'midikey',min:null,max:null,default:null,type:'substitution',},
      'velocity': {unit: 'midivel',min:null,max:null,default:null,type:'substitution',},
      'initialAttenuation': {unit: 'cB',min:0,max:1440,default:0,type:'value',},
      'endloopAddrsCoarseOffset': {unit: 'smpls',min:null,max:null,default:null,type:'sample',},
      'coarseTune': {unit: 'semitone',min:-120,max:120,default:0,type:'value',},
      'fineTune': {unit: 'cent',min:-99,max:99,default:0,type:'value',},
      'sampleID': {unit: 'index',min:null,max:null,default:null,type:'index',},
      'sampleModes': {unit: 'bitflags',min:null,max:null,default:null,type:'sample',},
      'scaleTuning': {unit: 'cent_per_key',min:0,max:1200,default:100,type:'value',},
      'exclusiveClass': {unit: 'number',min:0,max:127,default:0,type:'sample',},
      'overridingRootKey': {unit: 'midikey',min:null,max:null,default:null,type:'sample',}
	};
	var setDefaults = function() {
		// Returns a default parameter object.
		var out = { };
		for (var thisParm in parmInfo) {
			out[thisParm] = parmInfo[thisParm].default;
		}
		return out;
	}
	var getCombiner = function(thisParm) {
		// determines the combining method for a particular sound parameter.  Check type first, then unit, then parent unit.
		var parmInfo = parmInfo[thisParm];
		var combiningFunction = combineParmsIgnoring;		// default to ignoring parms that might be from a newer version, etc.
		if (typeInfo[parmInfo.type] && typeInfo[parmInfo.type].combine)
			combiningFunction = typeInfo[parmInfo.type].combine;
		else if (unitInfo[parmInfo.unit] && unitInfo[parmInfo.unit].combine)
			combiningFunction = unitInfo[parmInfo.unit].combine;
		else if (unitInfo[parmInfo.unit] && unitInfo[parmInfo.unit].parent_unit) {
			var unitInfo2 = unitInfo[unitInfo[parmInfo.unit].parent_unit];
			if (unitInfo2.combine) combiningFunction = unitInfo2.combine;  // only one level of parents please!
		}
		return combiningFunction;
	}
	var combineParms = function(a,b,combineOverride) {
		// Combines parameters where b can override a, using the methods appropriate to each parameter's type or unit.
		// CombineOverride is optional for when you want to force a particular combining function in a situation.
		for (var thisParm in b) {
			var f = getCombiner(thisParm);
			if (combineOverride) combineOverride = f;
			f(a,b,thisParm);	// actually run the function-- it adds, substitutes, ignores, multiplies, etc.
		}
	}
	var matchRange = function(k,v,parms) {
		// Looks in the parameter or generator object and returns true if the given k>ey/v>elocity
		// range matches, false otherwise.
		if (parms.hasOwnProperty('keyRange')) {
			if (k < parms.keyRange[0]) return false;
			if ( k > parms.keyRange[1]) return false;
		}
		if (parms.hasOwnProperty('velRange')) {
			if (v < parms.velRange[0]) return false;
			if (v > parms.velRange[1]) return false;
		}
		return true;
	}
	var shallowClone = function(a) { return JSON.parse(JSON.stringify(s)); }
	//
	//	Adds the MIDI Map part to the parser, which we need to quickly look up MIDI patches.
	//
	var addMIDIMap = function (parser) {
		//-- save the results of these parser functions so we don't have to generate them again
		var presets = parser.presets = parser.getPresets();
		var instruments = parser.instruments = parser.getInstruments();
		//-- here's our new one
		var MIDIMap = parser.MIDIMap = { };
		//-- now scan all the presets
		for (var i = 0; i < presets.length; i++) {
			var thisPreset = presets[i]; var thisBank = thisPreset.header.bank;
			var thisMIDIProgram = thisPreset.header.preset;
			if (!MIDIMap.hasOwnProperty(thisBank)) MIDIMap[thisBank] = { };
			var myMap = MIDIMap[thisBank][thisMIDIProgram] = { preset: i, notes: [ ] };
			//--- after we create a MIDI sound, we scan all its notes to see how you make them.
			for (var j = 0; j < 128; j++) {
				myMap.notes[j] = processNoteSF2(parser,j,thisMIDIPorgram,thisBank, thisPreset);
			}		
		}		// end
	}

	//
	//	Install the soundfont into this object.  Depends of course on the sound font parsing module.
	//
	var parser = null;
	function loadSF2File(filedata) {
		var byteBuffer = new Uint8Array(reader.result);
		var parser = new sf2.Parser(byteBuffer);
		parser.parse();
		window.parser = parser;		// just for debugging purposes now-- what's in here exactly?
		addMIDIMap(parser);   // make sure to add the midi map.
	}
	//
	//	Process a note's related parameters before playing it.  Returns array of objects telling
	// 	the player what to play, or false if note data is not available (then the player can fallback
	// 	to a lesser quality level?)
	//
	this.processNoteSF2 = function (parser, noteNumber, noteVelocity, programNumber, bankNumber) {
		//--- find the preset in the MIDI map
		if (!parser.MIDIMap) return false;  // need the midi map generated after loading soundfont
		if (!parser.MIDIMap[bankNumber]) return false;
		if (!parser.MIDIMap[bankNumber][programNumber]) return false;
		var preset = parser.MIDIMap[bankNumber][programNumber];
		//--- set default parms and look for the global generator; at the preset level, the defaults are all zero because they are just added to instrument parameters.
		var noteParms = { }; var globalIndex = -1;
		for (var i = 0; i < preset.info.length; i++) {
			if (preset.info[i].generator && !present.info[i].generator.instrument) {
				combineParms(noteParms, preset.info[i].generator);  // global overrides defaults
				globalIndex = i; break;
			}
		}
		//--- now look for the presets matching our note and velocity.  There may be more than one, so
		//--- we add to an array.  Eventually at the sample level we have a tree of two levels of arrays,
		//--- which we can then compress back into a list of samples for the player to play.
		presetMatches = [ ];
		for (var i = 0; i < preset.info.length; i++) {
			if (i===globalIndex) continue;
			var thisGenerator = preset.info[i].generator;
			if (matchRange(noteNumber, noteVelocity, thisGenerator)) {
				var newPresetMatch = shallowClone(noteParms);	// copy the parms from global level
				combineParms(newPresetMatch, thisGenerator);
				presetMatches.push(newPresetMatch);
			}
		}
		//--- now, for each preset match, we have to locate and process the instrument.
		var instrumentMatches = [ ];
		for (var i = 0; i < presetMatches.length; i++) {
			if (presetMatches[i].instrument && parser.instruments && parser.instruments[presetMatches[i].instrument]) {
				var instrument = parser.instruments[presetMatches[i].instrument];
				var instParms = setDefaults();  // the instrument parms start out at standard defaults.  They are absolute physical values, unlike the preset level which is offsets.
				//--- now locate the global instrument zone if it exsts.
				var globalIndex = -1;
				for (var j = 0; j < instrument.info.length; j++) {
					var thisInfo = instrument.info[j];
					if (!thisInfo.generator.hasOwnProperty('sampleID')) {
						// found global: force-override defaults by always substituting
						combineParms(instParms, thisInfo.generator, combineParmsSubstituting);
						globalIndex = j; break;
					}
				}
				//--- now that we have found the global instrument, locate and create nodes for
				//--- all the instrument samples/notes we must play (possibly multiple).  For each,
				//--- we overwrite the globals for the instrument (which overwrote the defaults), then,
				//--- we use the combining method (typically adding) to combine in the preset level.
				for (var j = 0; j < instrument.info.length; j++) {
					if (j===globalIndex) continue;
					var thisInfo = instrument.info[j]; var thisGenerator = thisInfo.generator;
					var newInstrumentMatch = shallowCopy(instParms);
					combineParms(newInstrumentMatch, thisGenerator, combineParmsSubstituting);
				}
			} else continue;  // if instrument is not found, we just ignore that line
		}
	}
		
}


function loadSoundfont(files){
  var reader = new FileReader();
  reader.onload=function(e) {
	var byteBuffer = new Uint8Array(reader.result);
	var parser = new sf2.Parser(byteBuffer);
	parser.parse();
	window.parser = parser;		// just for debugging purposes now-- what's in here exactly?
  };
  reader.readAsArrayBuffer(files[0]);
}


</SCRIPT>
</HEAD>
<BODY ONLOAD="onLoadFunction()">
<h3>Audio Test</h3>
This is a test of various audio things.<br>
<button onclick="showDrawbar()">Show Drawbar Organ Controls</button>
<div style="display:none" id=drawbarstuff>
<table><tr><td class="control-cell">
Drawbars:<br>
<div id=drawbars class="control-container"></div>
</td><td class="control-cell">Envelope:
<div id=envelope class="control-container"></div>
</td><td class="control-cell">General Controls:<div id=generalcontrols class="control-container"></div></td></tr></table>
</div>
<hr>
Now the tiny synth, which I am expanding:<br>
Instrument Loaded Status: <span id="inststatus">Not Loaded</span><br>
<div style="width: 80vw; border: thick solid black;" id=tskeyboard></div>
<hr/>
Load MIDI file from local : <input type="file" onchange="loadMidi(this.files)"/><br/>
<button onclick="playMidi()">Play</button>
<button onclick="stopMidi()">Stop</button>
<div id="status"></div>
<br/><br/>
Loop : <input type="checkbox" onchange="synth.setLoop(this.checked)"/><br/>
MasterVol<br/>
<input type="range" value="50" min="0" max="100" oninput="synth.setMasterVol(this.value/100)"/><br/>
ReverbLev<br/>
<input type="range" value="50" min="0" max="100" oninput="synth.setReverbLev(this.value/100)"/><br/>

<br/><br/>
Quality : <select onchange="synth.setQuality(this.selectedIndex)"><option>Quality=0</option><option>Quality=1</option><option selected>Quality=2</option></select>
<br/>
Timbre : <select id="prog" onchange="SetProgram(this.selectedIndex)"></select>
<table><tr>
	<td class="control-cell">Inputs:
		<div id=midiinputs></div>
	</td>
	<td class="control-cell">Outputs:
		<div id=midioutputs></div>
	</td>
</tr></table>
Keyboard Channel: <input id=kbdchannel value="0"> 
<hr>
Now SoundFont Test:
Load Soundfont file from local : <input type="file" onchange="loadSoundfont(this.files)"/><br/>

</BODY>
</HTML>
