<!DOCTYPE html>
<HTML>
<HEAD>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<TITLE>Audio Test</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="pianokeys.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="drawbars.css">
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="pianokeys.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="midimsg.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="audiopolyfill.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript" SRC="tinysynth.js"></SCRIPT><!-- not needed for drawbar synth  - but testing none the less -->
<SCRIPT TYPE="text/javascript" LANGUAGE="javascript">
function el(x) { return document.getElementById(x); }

"use strict";
//
//
//	MY NEW FAVORITE PROGRAM: A real Synthesizer I made myself using Web Audio!  With hammond organ like feature and
//	tremolo and vibrato and pitch bend!  It is an all-round instrument object, like a real instrument (and wired kind of like that inside).
//
//	Eventually it will replace the old sound module for Musical Playground, and add a whole suite of sound-based features like
//	making your own instruments, playing back the original soundfont ones with a release envelope (so bells sound more bell-like!),
//	running a simple General Midi suite without any soundfonts, etc.
//
//	Known limitations: The reason you get static if you play a bunch of notes in a row (i.e. sweeping the keyboard) with a Release Envelope,
//	is because the note is active until its release has fully played, and the resource it's using too much of is not volume (it still is staticy at low volume),
//	it's PROCESSOR TIME.  Of my 8 hyperthreaded cores, one of them, that runs the audio thread, is maxing out when you do that.
//
//	So no Release Envelope (or a shorter one-- the limiting factor is # of simultaneous notes) on low powered devices.  But otherwise it's fine!
//
function instrumentObject(inputCtx, harmonicsOverride, envelopeOverride, baseVelocityOverride) {
	//--- A simple and complete Instrument Object with additive harmonics (a.k.a. tonewheels), master volume switch, controllable note buffer using
	//--- the audio clock, envelope adjustments, and whatever else I need.  Pass the audio context when creating.
	//--- The override parameters are optional and can make instruments with different sounds.
	var instrument = this;
		var ctx = inputCtx;
	var max = function (a,b) { return (a>b) ? a : b; };  var min = function (a,b) { return (a<b) ? a : b; };
	var limitval = function(a,b,c) { if (a < b) a = b; if (a > c) a = c; return a; };
	var logAdjust = function(a) { return a*a*a; }   // adjust gain controls (between 0-1) by raising them to the 4th power since hearing is logarithmic (https://www.dr-lex.be/info-stuff/volumecontrols.html)
	//-- internal audio properties-- use set...() methods to change in realtime
	var harmonics = harmonicsOverride || [  [0.5, 8],[1.5, 8],[1, 8],[2, 8],[3, 8],[4, 8],[5, 8],[6, 8],[8, 8] ];   
	var envelope =  envelopeOverride || { "a": 20, "h": 0, "d": 40, "s": 60, "r": 40, "expFlag": 0 };  // A>ttack,H>old,D>ecay,S>ustain,R>elease, exponential
	var baseVelocity = baseVelocityOverride || 40;
	var controlResponse = 0.125;		// # of seconds for a control to take effect (smoothly).
	var drawbarMax = 8;				// max setting on drawbar (0-8)

	//-- this section encapsulates the idea of creating a new slider for the instrument.
	//-- the slider adjust function takes a slider input (always 0-1, and the setupSlider function limits actual inputs to that) and adjusts it to the
	//-- actual range needed by the audioParam.  the slider name is used to create public methods called set<name> and get<name> which
	//-- properly ramp up the audio param.
	var sliderValues = { };
	var setupSlider = function(sliderName, initialSliderValue, sliderAdjustFunction, audioParam) {
		var initialAdjustedValue = sliderAdjustFunction(limitval(initialSliderValue,0,1));
		sliderValues[sliderName] = initialSliderValue;
		audioParam.value = initialAdjustedValue;
		instrument["set" + sliderName] = function(v, startTime) {
			startTime = startTime || ctx.currentTime;
			sliderValues[sliderName] = v;
			audioParam.setTargetAtTime(sliderAdjustFunction(limitval(v,0,1)), startTime, controlResponse/5);
		};
		instrument["get" + sliderName] = function() { return sliderValues[sliderName]; }
	};

	//-- this section implements the main volume control -- you supply a linear ratio 0-1, it applies the exponential or power function to make it sound right.
	var mainGain = ctx.createGain();	// main volume control, all oscillators are connected to it
	setupSlider("MainVolume", 1.0, function(v) { return logAdjust(v); }, mainGain.gain);
	
	//-- here is the main connection for notes to attach to.  If no dynamics compressor gets added, it's also the final connection to outside.
	var noteAttachPoint = mainGain;   // we set this to wherever the notes are supposed to connect to
	var outsideConnector = mainGain;	// main gain connects to outside too (speakers/recording), UNLESS we add other things below, like a dynamic compressor.
	
	//-- our handy organ has wiring for "dynamics compression" to keep everything from overloading.  All current browsers except IE support it (but in case of older browsers we leave it out if it's not there)
	var compressor = null;
	if (ctx.createDynamicsCompressor) {
		compressor = ctx.createDynamicsCompressor();
		mainGain.connect(compressor); outsideConnector = compressor;
		compressor.threshold.setValueAtTime(-50, ctx.currentTime);	// values from MDN page at https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode
		compressor.knee.setValueAtTime(40, ctx.currentTime);
		compressor.ratio.setValueAtTime(12, ctx.currentTime);
		compressor.attack.setValueAtTime(0.25, ctx.currentTime);
		compressor.release.setValueAtTime(0.25, ctx.currentTime)		
	}	
	
	//-- this section implements the drawbars, as constant-source nodes.  You can change their "offset" AudioParam using any of the
	//-- ramping or setting functions.
	var drawbarGains = [ ];		// note below: drawbars are volume controls, hence, should use power formula since hearing is logarithmic!
	var drawbarToGain = function(v) { var v1 = (limitval(v,0,drawbarMax)/drawbarMax); return logAdjust(v1); }
	for (var i = 0; i < harmonics.length; i++) {
		drawbarGains[i] = ctx.createConstantSource(); 
		drawbarGains[i].offset.value = drawbarToGain(harmonics[i][1]); 
		drawbarGains[i].start();
	}
	this.getNumDrawbars = function() { return harmonics.length; }
	this.getMaxDrawbarValue = function() { return drawbarMax; }
	this.getDrawbarDefault = function(dbindx) { return harmonics[dbindx][1]; }
	this.setDrawbar = function(dbindx, dbval, startTime) { 
		startTime = startTime || ctx.currentTime; harmonics[dbindx][1] = dbval;
		drawbarGains[dbindx].offset.setTargetAtTime(limitval(dbval,0,drawbarMax)/drawbarMax,startTime, controlResponse/5);
	}
	this.setDrawbarWaveform = function(dbindx, waveform, startTime) {
		
	}
	
	//-- the instrument has an array of frequency modulators that connect to notes using the function connectFrequencyModulators.
	var frequencyModulators = [ ];
	var connectFrequencyModulators = function(sourceNode) {
		if (sourceNode.detune) { 
			for (var i = 0; i < frequencyModulators.length; i++)
				frequencyModulators[i].connect(sourceNode.detune); 
		}   // ignore if browser doesn't have detune (e.g. Safari)
	};
	
	//-- this section implements a tremolo control (Low Frequency Oscillator for frequency).
	//-- You must connect the frequencyModulator (which may be modified below to add pitch bend) to your notes' detune AudioParam
	//-- for it to work.  Some browsers don't have detune, so use connectFrequencyModulator to handle it.
	var tremolo = ctx.createOscillator();
	var tremoloGain = ctx.createGain(); frequencyModulators.push(tremoloGain);  
	tremolo.connect(tremoloGain);
	setupSlider("TremoloFrequency",0.45,function(fin) { fin = logAdjust(fin); fin = fin * 2 - 1; return 20 + fin * 19; }, tremolo.frequency);  // slider with range 1hz to 38hz, logarithmic
	setupSlider("TremoloGain",0,function(gin) { return gin * 100; }, tremoloGain.gain);   // the 100 in this line is maximum cents displacement for tremolo.
	tremolo.start();
	
	//-- here we implement pitch bend, which is just like tremelo, but the slider controls the pitch bend directly.
	//-- Another one controls pitch bend sensitivity.  Pattern: constant source (1.0) goes through gain controlled by pitch bend controller
	//-- (output -1 to 1), goes through another gain controlled by pitch sensitivity controller (output -9600 to 9600 cents).
	var pitchBend = ctx.createConstantSource(); pitchBend.offset.value = 1.0;
	var pitchBendGain = ctx.createGain(); pitchBend.connect(pitchBendGain); 
	var pitchBendSensitivityGain = ctx.createGain(); pitchBendGain.connect(pitchBendSensitivityGain);
	frequencyModulators.push(pitchBendSensitivityGain);	//-- after it goes through pitch bend and sensitivity, it can modify the note as a frequency modulator.
	setupSlider("PitchBend",0.5, function(pin) { return (pin - 0.5) * 2; }, pitchBendGain.gain);	// the pitch bend gain outputs -1 to 1.
	setupSlider("PitchBendSensitivity",0.04,function(psin) { return (psin) * 9500 + 1; }, pitchBendSensitivityGain.gain);    //-- sensitivity needs to expand that to -9600 to 9600 (cents).  Wow!
	pitchBend.start();
	
	//-- here we add a vibrato circuit.  Vibrato is just an LFO (Low Frequency Oscillator) attached to the gain param of the main volume.
	var vibrato = ctx.createOscillator();
	var vibratoGain = ctx.createGain(); vibratoGain.connect(mainGain.gain); 
	vibrato.connect(vibratoGain);
	setupSlider("VibratoFrequency",0.45,function(fin) { fin = logAdjust(fin); fin = fin * 2 - 1; return 20 + fin * 19; }, vibrato.frequency);  // slider with range 1hz to 38hz, logarithmic
	setupSlider("VibratoGain",0,function(gin) { return gin * 0.4; }, vibratoGain.gain);   // 0.3 means up to 40% of the volume level changes.
	vibrato.start();
	
	//-- connect the instrument to external audio or processing
	this.connect = function(destNode) { outsideConnector.connect(destNode); }	// whatever the outside connector is, gets connected.
	
	//-- this section implements envelopes on any AudioParam
	this.setEnvelope = function(parmName, newValue, startTime) { 	// note: setting envelope during playback uses JS clock, less accurate
		startTime = startTime || ctx.currentTime;
		setTimeout(function() { envelope[parmName] = newValue; }, 1000*min(0, startTime - ctx.currentTime)); 
	} 
	this.getEnvelopeObject = function() { return envelope; }
	this.applyEnvelope = function(audioParam, startValue, maxValue, parms, startTime, noteOnFlag) {  // returns time when envelope call will be finished
		startTime = startTime || ctx.currentTime;
		if (startValue===maxValue) { audioParam.setValueAtTime(startValue,startTime); return; }  // no change-- just set the value at the time
		var rampFunc = function(v,t) { return audioParam.linearRampToValueAtTime(v,t); };  // default ramp function: linear
		var pt = function(pName) { return max(0.005,parms[pName]/1000.0); }  // function for parameters based on time
		var expFlag = parms["expFlag"]; 	// but exponential is a fun option to make bells, for example
		if (expFlag) rampFunc = function(v,t) { if (v===0) v = 0.001; return audioParam.exponentialRampToValueAtTime(v,t); };
		if (expFlag) { startValue = startValue != 0 ? startValue : 0.001; maxValue = maxValue != 0 ? maxValue : 0.001; }  // no zeroes for exponential envelopes
		if (noteOnFlag) {		// note-on part of envelope
			var endAttack = startTime + pt("a"); var endHold = endAttack + pt("h"); var endDecay = endHold + pt("d");
			audioParam.setValueAtTime(startValue,startTime); rampFunc(maxValue,endAttack);	// start and attack ("a")
			audioParam.setValueAtTime(maxValue,endHold);  // hold ("h");
			rampFunc(parms["s"]/100*maxValue,endDecay);  // decay ("d") and sustain % of max value ("s");
			return endDecay;
		} else { 				// note-off part of envelope
			var releaseParm = pt("r"); 
			var endRelease = startTime + releaseParm; var rightBeforeStart = startTime - 0.001;
			audioParam.cancelScheduledValues(endRelease-0.01);   rampFunc(startValue, endRelease);  // cancel any leftover events from note-on before starting note-off release
			return endRelease;
		}
	};
	
	//-- this section implements the main note generation and playback
	var noteModules = [ ];			// all the notes go here
	this.getNumNotesPlaying = function() { return noteModules.length; }   // handy for debugging or displays -- includes those still releasing after being let go
	var noteNumberToFreq = function(midi) { return Math.pow(2, (midi - 69) / 12) * 440.0; }		// convert note-# to frequency
	var noteModule = function(noteNumber, noteVelocity, startTime) {   // create a note and start it at the given clock time; it's buffered till it plays
		//-- object properties
		var note = this; startTime = startTime || ctx.currentTime;	// default start time for note on is now
		note.noteNumber = noteNumber; note.velocity = noteVelocity; note.startTime = startTime; // save parameters for later
		note.noteOn = true; note.noteSuppressed = false;
		var srcNodes = [ ]; var eGainNodes = [ ];    // we keep track of src's, drawbar gain, and envelope gain nodes
		//--- object methods including stopping the note
		this.stop = function(startTime) { 
			startTime = startTime || ctx.currentTime;	// default start time for note off is now
			if (!note.noteOn) return; note.noteOn = false;   // stop only happens once
			var maxEndedTime = ctx.currentTime;
			for (var i = 0; i < harmonics.length; i++) {
				maxEndedTime = max(maxEndedTime, instrument.applyEnvelope(eGainNodes[i].gain, 0, 1, envelope, startTime, false));
			}
			for (var i = 0; i < harmonics.length; i++) {
				if (i===0) srcNodes[i].onended = function() { note.removeMe(); };  // after note is ended it is removed from note array
				srcNodes[i].stop(maxEndedTime + 0.010);
			}
		};
		this.removeMe = function() {		// removes this object from the instrument's note buffer
			for (var i = 0; i < noteModules.length; i++) {  if (noteModules[i]===note) { noteModules.splice(i,1); return; }  }
		};
		//--- main constructor which also starts the note playing
		for (var i = 0; i < harmonics.length; i++) { 
			var src = ctx.createOscillator(); 
			var eGain = ctx.createGain(); var dGain = ctx.createGain(); var vGain = ctx.createGain();  // e>nvelope, d>rawbar, v>elocity
			srcNodes.push(src); eGainNodes.push(eGain);  // note: dGain is connected to instrument's drawbar, automatically changing when it does
			src.type = (harmonics[i].length > 2 ? harmonics[i][2] : 'sine');   // easily change wave type with fancier harmonics array
			dGain.gain.value = 0; drawbarGains[i].connect(dGain.gain);   // make sure to zero out the drawbar gain node before attaching the drawbar to it-- initial value and drawbar value are added!
			eGain.gain.value = 0; vGain.gain.value = (baseVelocity/127)*(noteVelocity/127)/harmonics.length;
			src.frequency.value = noteNumberToFreq(noteNumber) * harmonics[i][0];
			connectFrequencyModulators(src); 	// allow notes to be modulated by tremolo, pitch bend
			src.connect(eGain); eGain.connect(dGain); dGain.connect(vGain); vGain.connect(noteAttachPoint);
			instrument.applyEnvelope(eGain.gain, 0, 1, envelope, startTime, true);
			src.start(startTime);
		}
	};
	
	//--- this section implements a public MIDI interface
	this.midiSend = function(msg) {
	}
	
	//--- this section connects to the keyboard.
	this.noteFunctionAdder = function (x) {
		x.keyDown = false;
		//--- Generates complex harmonics note using harmonics array setting above
		x.onNoteOn = function(noteNumber, channel, velocity, keyButton, startTime) {
			if (x.keyDown) return;	// debounce
			if (keyButton) keyButton.style.backgroundColor = "pink";
			x.keyDown = true;
			noteModules.push(new noteModule(noteNumber, velocity, startTime));
		};
		x.onNoteOff = function(noteNumber, channel, keyButton, startTime) {
			x.keyDown = false;
			if (keyButton) keyButton.style.backgroundColor = "";
			for (var i = 0; i < noteModules.length; i++) {	// set all the notes in the instrument that are that note number to "stopping".
				if (noteModules[i].noteNumber === noteNumber) noteModules[i].stop(startTime);
			}
		};
	};
}

function recordPlaybackObject() {
	this.notes = [ ];		// a note is an array of objects with properties delta and midiMessage.
	this.startRecording = function() { this.notes = [ ]; }
}

function insertDrawbars(destDiv, instrumentObject) {
	//--- inserts drawbars into a Div to control an instrument's harmonics
	var ndb = instrumentObject.getNumDrawbars();
	for (var i = 0; i < ndb; i++) {
		var setupDrawbar = function(db,ndb) {
			dbl = ["16'","5<sup>1/3</sup>'","8'","4'","2<sup>2/3</sup>'","2","1<sup>3/5</sup>'","1<sup>1/3</sup>'","1'"];
			var newDrawbar = document.createElement("input");
			newDrawbar.type = "range";
			newDrawbar.className = "drawbar";
			newDrawbar.min = 0; newDrawbar.max = 8;
			newDrawbar.value = instrumentObject.getDrawbarDefault(ndb-db-1);
			newDrawbar.addEventListener("change", function(evt) {
				instrumentObject.setDrawbar(ndb-db-1, parseInt(newDrawbar.value,10), 0);
			});
			destDiv.appendChild(newDrawbar);
			var drawbarLabel = document.createElement("span"); drawbarLabel.innerHTML = dbl[ndb-db-1];
			var drawbarBr = document.createElement("br"); destDiv.appendChild(drawbarLabel); destDiv.appendChild(drawbarBr);
		};
		setupDrawbar(i,ndb);
	}
}

function insertEnvelope(destDiv, instrumentObject) {
	//--- draws the envelope controls
	var ienv = instrumentObject.getEnvelopeObject();
	var addParameter = function(parmName, minValue, maxValue, label) {
		var newSlider = document.createElement("input"); newSlider.type = "range";
		newSlider.className = "other-slider";
		newSlider.min = minValue; newSlider.max = maxValue; newSlider.value = ienv[parmName];
		var sliderLabel = document.createElement("span"); sliderLabel.innerText = label;
		var sliderBr = document.createElement("br");
		newSlider.addEventListener("change", function(evt) {
			instrumentObject.setEnvelope(parmName, parseInt(newSlider.value,10));
		});
		destDiv.appendChild(newSlider); destDiv.appendChild(sliderLabel); destDiv.appendChild(sliderBr);
	};
	var maxDelay = 1000;		// max delay for an envelope time parameter is 1s
	addParameter("a",0,maxDelay,"Attack");
	addParameter("h",0,maxDelay,"Hold");
	addParameter("d",0,maxDelay,"Decay");
	addParameter("s",0,100,"Sustain (%Max)");
	addParameter("r",0,maxDelay*4,"Release");		// Release allows much longer time configuration to make ringing sounds.
	addParameter("expFlag",0,1,"Exponential");
}

function insertGeneralControls(destDiv, instrumentObject) {
	//--- some more controls I like
	var addZeroOneSlider = function(name, sliderName) {
		var newSlider = document.createElement("input"); newSlider.type = "range"; newSlider.className = "other-slider";
		newSlider.min = 0; newSlider.max = 1; newSlider.step = 0.05; newSlider.value = instrumentObject["get" + sliderName]();
		var sliderLabel = document.createElement("span"); sliderLabel.innerText = name;
		var sliderBr = document.createElement("br");
		newSlider.addEventListener("change", function(evt) { instrumentObject["set"+sliderName](parseFloat(newSlider.value),0); });
		destDiv.appendChild(newSlider); destDiv.appendChild(sliderLabel); destDiv.appendChild(sliderBr);
	};
	addZeroOneSlider("Volume", "MainVolume");
	addZeroOneSlider("Tremolo Freq", "TremoloFrequency");
	addZeroOneSlider("Tremolo Gain", "TremoloGain");
	addZeroOneSlider("Pitch Bend", "PitchBend");
	addZeroOneSlider("Pitch Bend Sensitivity", "PitchBendSensitivity");
	addZeroOneSlider("Vibrato Freq", "VibratoFrequency");
	addZeroOneSlider("Vibrato Gain", "VibratoGain");
}

var adjWave;
var synth; 		// tinysynth

//--- tinysynth testing routines from tinysynth website

function loadMidi(files){
  var reader = new FileReader();
  reader.onload=function(e) {
    synth.loadMIDI(reader.result);
  };
  reader.readAsArrayBuffer(files[0]);
}
function playMidi(){
  synth.playMIDI();
}
function stopMidi(){
  synth.stopMIDI();
}
function SetProgram(p){
  synth.send([0xc0,p]);
}
function Init(){
  synth=new WebAudioTinySynth({voices:64});
  for(var i=0;i<128;++i){
    var o=document.createElement("option");
    o.innerHTML=synth.getTimbreName(0,i);
    document.getElementById("prog").appendChild(o);
  }
  synth.setSoundfontPath("./bsoundfonts");
  synth.loadInstruments([0,11,128],function(errObj) {	// load piano, drums, vibes
	  el("inststatus").innerText = errObj.errMsg;
  	  }, function() { el("inststatus").innerText = "Loaded successfully"; console.log("Instruments loaded."); },
	  function(i,n) { console.log("Loading Instrument " + i + " of " + n); });  // shows example of progress callback
  synth.setQuality(2);
  setInterval(function(){
    var st=synth.getPlayStatus();
    document.getElementById("status").innerHTML="Play:"+st.play+"  Pos:"+st.curTick+"/"+st.maxTick;
  },100);
}

var midiAccess;

function setupMidiInput(midiInputName) {
	navigator.requestMIDIAccess({software: true}).then(function(m) {
		var inputs = midiAccess.inputs;
		inputs.forEach(function(port,key) {

		});
	});
}

function onLoadFunction() {
	ctx = getPolyfillAudioContext();
	if (ctx) {
		//--- now add event listeners for controls of the drawbar organ
		adjWave = new instrumentObject(ctx);
		adjWave.connect(ctx.destination);   // connect my organ directly to the speakers :-) 
		pianoKeyDisplay.createPianoKeyboard(el("keyboard"),0,127,25,21,108,adjWave.noteFunctionAdder);
		insertDrawbars(el("drawbars"),adjWave);
		insertEnvelope(el("envelope"),adjWave);
		insertGeneralControls(el("generalcontrols"),adjWave);
	}
	//--- tinysynth keyboard setup
	pianoKeyDisplay.createPianoKeyboard(el("tskeyboard"),0,127,25,21,108,function(x) {
		x.keyDown = false;
		x.onNoteOn = function(noteNumber, channel, velocity, keyButton, startTime) {
			if (x.keyDown) return;	// debounce
			if (keyButton) keyButton.style.backgroundColor = "pink";
			x.keyDown = true;
			synth.send([0x90,noteNumber & 0x7F,velocity & 0x7F]);
		};
		x.onNoteOff = function(noteNumber, channel, keyButton, startTime) {
			if (!x.keyDown) return; x.keyDown = false;
			if (keyButton) keyButton.style.backgroundColor = "";
			synth.send([0x80,noteNumber & 0x7F,0]);
		};
	});
	Init();  // init tiny synth
	synth.setupMidiDevices(function() { refreshMidiUI(); }, function() { el("midiinputs").innerText = "No Midi Device Support"; } )
}

var numInputCheckboxes = 0, numOutputCheckboxes = 0;

function readMidiUI() {
	// reads the checkboxes in the input/output section to set up inputs and outputs
	var inputList = [ ];
	for (var i = 0; i < numInputCheckboxes; i++) {
		if (el("midiinput_" + i).checked) inputList.push(el("midiinput_" + i).getAttribute("midiid"));
	}
	synth.setInput(inputList);
	var outputList = [ ];
	for (var i = 0; i < numOutputCheckboxes; i++) {
		if (el("midioutput_" + i).checked) outputList.push(el("midioutput_" + i).getAttribute("midiid"));
	}
	synth.setOutput(outputList);
}

function refreshMidiUI() {
	synth.refreshInputs(); synth.refreshOutputs();
	var myInputs = synth.getInputs(); var myOutputs = synth.getOutputs();
	el("midiinputs").innerHTML = ""; numInputCheckboxes = myInputs.length;
	for (var i = 0; i < myInputs.length; i++) {
		var newCheckbox = document.createElement("input"); newCheckbox.type="checkbox";
		newCheckbox.checked = (synth.selectedInputs.indexOf(myInputs[i].id) !== -1);
		newCheckbox.setAttribute("midiid",myInputs[i].id);
		newCheckbox.id = "midiinput_" + i;
		newCheckbox.addEventListener("click",readMidiUI);
		var newLabel = document.createElement("span");
		newLabel.innerText = myInputs[i].name;
		var newBr = document.createElement("br");
		el("midiinputs").appendChild(newCheckbox); el("midiinputs").appendChild(newLabel); el("midiinputs").appendChild(newBr);
	}
	var myOutputs = synth.getOutputs(); var myOutputs = synth.getOutputs();
	el("midioutputs").innerHTML = ""; numOutputCheckboxes = myOutputs.length;
	for (var i = 0; i < myOutputs.length; i++) {
		var newCheckbox = document.createElement("input"); newCheckbox.type="checkbox";
		newCheckbox.checked = (synth.selectedOutputs.indexOf(myOutputs[i].id) !== -1);
		newCheckbox.setAttribute("midiid",myOutputs[i].id);
		newCheckbox.id = "midioutput_" + i;
		newCheckbox.addEventListener("click",readMidiUI);
		var newLabel = document.createElement("span");
		newLabel.innerText = myOutputs[i].name;
		var newBr = document.createElement("br");
		el("midioutputs").appendChild(newCheckbox); el("midioutputs").appendChild(newLabel); el("midioutputs").appendChild(newBr);
	}
}

function showDrawbar() {
	el('drawbarstuff').style.display = '';	
}

</SCRIPT>
</HEAD>
<BODY ONLOAD="onLoadFunction()">
<h3>Audio Test</h3>
This is a test of various audio things.<br>
<button onclick="showDrawbar()">Show Drawbar Organ</button>
<div style="display:none" id=drawbarstuff>
<div style="width: 80vw; border: thick solid black;" id=keyboard></div>
<table><tr><td class="control-cell">
Drawbars:<br>
<div id=drawbars class="control-container"></div>
</td><td class="control-cell">Envelope:
<div id=envelope class="control-container"></div>
</td><td class="control-cell">General Controls:<div id=generalcontrols class="control-container"></div></td></tr></table>
</div>
<hr>
Now the tiny synth, which I am expanding:<br>
Instrument Loaded Status: <span id="inststatus">Not Loaded</span><br>
<div style="width: 80vw; border: thick solid black;" id=tskeyboard></div>
<hr/>
Load MIDI file from local : <input type="file" onchange="loadMidi(this.files)"/><br/>
<button onclick="playMidi()">Play</button>
<button onclick="stopMidi()">Stop</button>
<div id="status"></div>
<br/><br/>
Loop : <input type="checkbox" onchange="synth.setLoop(this.checked)"/><br/>
MasterVol<br/>
<input type="range" value="50" min="0" max="100" oninput="synth.setMasterVol(this.value/100)"/><br/>
ReverbLev<br/>
<input type="range" value="50" min="0" max="100" oninput="synth.setReverbLev(this.value/100)"/><br/>

<br/><br/>
Quality : <select onchange="synth.setQuality(this.selectedIndex)"><option>Quality=0</option><option>Quality=1</option><option selected>Quality=2</option></select>
<br/>
Timbre : <select id="prog" onchange="SetProgram(this.selectedIndex)"></select>
<table><tr>
	<td class="control-cell">Inputs:
		<div id=midiinputs></div>
	</td>
	<td class="control-cell">Outputs:
		<div id=midioutputs></div>
	</td>
</tr></table>
</BODY>
</HTML>
